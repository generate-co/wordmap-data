<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word Map - Optimized</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
      background: #000;
    }
    canvas {
      display: block;
      background: #000;
    }
    #version {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 4px 8px;
      font-size: 12px;
      font-family: monospace;
      color: #fff;
      border-radius: 4px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="version">v0.5.2</div>
  <canvas></canvas>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    const VERSION = "v0.5.2";
    document.getElementById("version").textContent = VERSION;

    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");

    const WIDTH = window.innerWidth;
    const HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    const centerX = WIDTH / 2;
    const centerY = HEIGHT / 2;
    const focalLength = 400;
    const baseFontSize = 10;

    let data = [];
    let angle = 0;
    let dragging = false;
    let lastX = 0;
    let dragVelocity = 0;
    const decay = 0.95;

    const MAX_WORDS = 15000;
    const URL = "word_positions_1500000_clean.json?t=" + Date.now();

    fetch(URL)
      .then(res => res.json())
      .then(json => {
        // ✅ 頻出順でランク昇順ソート → 上位15000語のみ使用
        data = json
          .filter(d => typeof d.rank === "number")
          .sort((a, b) => a.rank - b.rank)
          .slice(0, MAX_WORDS);

        // ✅ x/y/z を視覚用に正規化
        const xExtent = d3.extent(data, d => d.x);
        const yExtent = d3.extent(data, d => d.y);
        const zExtent = d3.extent(data, d => d.z);

        const xScale = d3.scaleLinear().domain(xExtent).range([-300, 300]);
        const yScale = d3.scaleLinear().domain(yExtent).range([-300, 300]);
        const zScale = d3.scaleLinear().domain(zExtent).range([-1.2, 1.2]);

        data.forEach(d => {
          d.x = xScale(d.x);
          d.y = yScale(d.y);
          d.z = zScale(d.z);
        });

        requestAnimationFrame(render);
      });

    // 🖱 マウスドラッグによる視点操作
    canvas.addEventListener("mousedown", e => {
      dragging = true;
      lastX = e.clientX;
    });
    window.addEventListener("mousemove", e => {
      if (dragging) {
        const deltaX = e.clientX - lastX;
        dragVelocity = deltaX * 0.005;
        lastX = e.clientX;
      }
    });
    window.addEventListener("mouseup", () => {
      dragging = false;
    });

    function render() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      if (!dragging) dragVelocity *= decay;
      angle += dragVelocity + 0.0005;

      const sinA = Math.sin(angle);
      const cosA = Math.cos(angle);

      for (let i = 0; i < data.length; i++) {
        const d = data[i];

        const x3D = d.x * cosA - d.z * sinA;
        const z3D = d.x * sinA + d.z * cosA;
        const y3D = d.y;

        const perspective = focalLength / (focalLength - z3D);
        const screenX = x3D * perspective + centerX;
        const screenY = y3D * perspective + centerY;
        const fontSize = baseFontSize * perspective;

        const maxZ = 1.5;
        const alpha = Math.max(0.1, 1 - (z3D / maxZ));

        if (
          screenX < -50 || screenX > WIDTH + 50 ||
          screenY < -50 || screenY > HEIGHT + 50 ||
          fontSize < 4 || fontSize > 100
        ) continue;

        ctx.font = `${fontSize}px sans-serif`;
        ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(d.word, screenX, screenY);
      }

      requestAnimationFrame(render);
    }
  </script>
</body>
</html>